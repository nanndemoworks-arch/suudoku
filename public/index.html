<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Sudoku Trainer â€” ç„¡é™ãƒ¬ãƒ™ãƒ«</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#ffffff">

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 (UMD) & Babel (for JSX in-browser) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html, body { height: 100%; background: #fafafa; }
    .border { border-color: #e5e7eb; } /* ensure border color */
  </style>
</head>
<body class="min-h-screen text-neutral-900">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    (function(){
      if (typeof String.prototype.padStart !== 'function') {
        String.prototype.padStart = function(targetLength, padString){
          targetLength = targetLength | 0; padString = String(padString || ' ');
          var str = String(this); while (str.length < targetLength) { str = padString + str; }
          return str.length > targetLength ? str.slice(str.length - targetLength) : str;
        };
      }
      if (typeof window !== 'undefined') {
        if (typeof window.requestAnimationFrame !== 'function') {
          window.requestAnimationFrame = function(cb){ return setTimeout(function(){ cb(Date.now()); }, 16); };
        }
        if (typeof window.cancelAnimationFrame !== 'function') {
          window.cancelAnimationFrame = function(id){ clearTimeout(id); };
        }
      }
    })();

    const { useEffect, useMemo, useRef, useState } = React;

    const N = 9, SIZE = 81;
    const range = (n) => Array.from({length:n}, (_,i)=>i);
    const idx = (r,c)=> r*N+c;
    const rowOf = (i)=> Math.floor(i/N);
    const colOf = (i)=> i%N;
    const clone = (b)=> b.slice();
    const shuffle = (arr)=> { const a = arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=a[i]; a[i]=a[j]; a[j]=t; } return a; };

    function candidatesFor(board, i){
      if (board[i] !== 0) return [];
      const r=rowOf(i), c=colOf(i);
      const br=Math.floor(r/3)*3, bc=(c/3|0)*3;
      const used=new Set();
      for(let k=0;k<N;k++){ used.add(board[idx(r,k)]); used.add(board[idx(k,c)]); }
      for(let rr=br; rr<br+3; rr++) for(let cc=bc; cc<bc+3; cc++) used.add(board[idx(rr,cc)]);
      const cand=[]; for(let n=1;n<=9;n++) if(!used.has(n)) cand.push(n);
      return cand;
    }
    function isSafe(board,i,n){
      const r=rowOf(i), c=colOf(i);
      for(let k=0;k<N;k++) if(board[idx(r,k)]===n || board[idx(k,c)]===n) return false;
      const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
      for(let rr=br; rr<br+3; rr++) for(let cc=bc; cc<bc+3; cc++) if(board[idx(rr,cc)]===n) return false;
      return true;
    }
    function findMRVIndex(board){
      let best=-1, bestCount=10;
      for(let i=0;i<SIZE;i++) if(board[i]===0){
        const cnt=candidatesFor(board,i).length;
        if(cnt<bestCount){ best=i; bestCount=cnt; if(cnt===1) break; }
      }
      return best;
    }
    function solveBoard(b0){
      const b=clone(b0); let steps=0, backtracks=0;
      const stack=[];
      const step=()=>{
        const first=findMRVIndex(b);
        if(first===-1) return true;
        const options=shuffle(candidatesFor(b,first));
        stack.push({i:first, options, tried:[]});
        while(stack.length){
          const top=stack[stack.length-1]; steps++;
          if(!top.options.length){ backtracks++; b[top.i]=0; stack.pop(); if(!stack.length) return false; continue; }
          const n=top.options.pop(); top.tried.push(n);
          if(isSafe(b, top.i, n)){
            b[top.i]=n;
            const nextI=findMRVIndex(b);
            if(nextI===-1) return true;
            const nextOptions=shuffle(candidatesFor(b, nextI));
            stack.push({i:nextI, options:nextOptions, tried:[]});
          }
        }
        return false;
      };
      const ok=step();
      return { solved: ok, board: b, steps, backtracks };
    }
    function countSolutions(b0, limit=2){
      const b=clone(b0); let count=0;
      const dfs=()=>{
        if(count>=limit) return true;
        let i=-1, min=10, opts=[];
        for(let k=0;k<SIZE;k++) if(b[k]===0){
          const c=candidatesFor(b,k);
          if(c.length<min){ min=c.length; i=k; opts=c; if(min===1) break; }
        }
        if(i===-1){ count++; return count>=limit; }
        for(let t=0;t<opts.length;t++){ const n=opts[t]; if(isSafe(b,i,n)){ b[i]=n; if(dfs()) return true; b[i]=0; } }
        return false;
      };
      dfs(); return count;
    }
    function generateSolvedBoard(){
      const b=Array(SIZE).fill(0);
      for(let box=0; box<9; box+=4){
        const nums=shuffle(range(9).map(n=>n+1));
        let t=0; const br=Math.floor(box/3)*3, bc=(box%3)*3;
        for(let r=0;r<3;r++) for(let c=0;c<3;c++) b[idx(br+r, bc+c)] = nums[t++];
      }
      return solveBoard(b).board;
    }
    function rateDifficulty(puzzle){
      const {steps, backtracks} = solveBoard(puzzle);
      return steps + backtracks*50;
    }
    function targetForLevel(level){
      const empties=Math.min(60, Math.max(26, 24 + Math.round(level*2)));
      const diff=Math.min(20000, Math.round(1000 + Math.pow(1.25, Math.min(level,40))*200));
      return { emptiesTarget:empties, diffTarget:diff };
    }
    function generatePuzzle(level, maxAttempts=8000){
      const solution=generateSolvedBoard();
      let puzzle=solution.slice();
      const {emptiesTarget}=targetForLevel(level);
      const cells=shuffle(range(SIZE));
      let attempts=0;
      for(const i of cells){
        if(attempts++>maxAttempts) break;
        if(puzzle[i]===0) continue;
        const j=idx(8-rowOf(i), 8-colOf(i));
        const bi=puzzle[i], bj=puzzle[j];
        puzzle[i]=0; if(j!==i) puzzle[j]=0;
        const uniq = countSolutions(puzzle,2)===1;
        if(!uniq){ puzzle[i]=bi; if(j!==i) puzzle[j]=bj; continue; }
        if(puzzle.filter(x=>x===0).length >= emptiesTarget) break;
      }
      while(puzzle.filter(x=>x===0).length < emptiesTarget && attempts++ < maxAttempts){
        const i=Math.floor(Math.random()*SIZE);
        if(puzzle[i]===0) continue;
        const backup=puzzle[i]; puzzle[i]=0;
        if(countSolutions(puzzle,2)!==1) puzzle[i]=backup;
      }
      const difficulty=rateDifficulty(puzzle);
      return { puzzle, solution, difficulty, targets: targetForLevel(level) };
    }

    const Badge = (props)=> <span className="px-2 py-0.5 text-xs rounded-full border bg-white/60">{props.children}</span>;
    const Button = (props)=>{
      const variant = props.variant || "primary";
      const style = variant === "outline"
        ? "border px-3 py-2 rounded-lg hover:bg-neutral-50 disabled:opacity-50"
        : (variant === "secondary"
          ? "px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300 disabled:opacity-50"
          : "px-3 py-2 rounded-lg bg-black text-white hover:bg-neutral-800 disabled:opacity-50");
      return <button className={style} onClick={props.onClick} disabled={props.disabled}>{props.children}</button>;
    };
    const Card = (p)=> <div className={"rounded-2xl border bg-white shadow-sm " + (p.className||"")}>{p.children}</div>;
    const CardHeader = (p)=> <div className={"p-4 border-b " + (p.className||"")}>{p.children}</div>;
    const CardTitle = (p)=> <div className={"text-base font-semibold " + (p.className||"")}>{p.children}</div>;
    const CardContent = (p)=> <div className={"p-4 " + (p.className||"")}>{p.children}</div>;

    function fmtTime(secs){
      const h = String(Math.floor(secs/3600)).padStart(2,'0');
      const m = String(Math.floor((secs%3600)/60)).padStart(2,'0');
      const s = String(Math.floor(secs%60)).padStart(2,'0');
      return (h!=="00"? h+":" :"") + m + ":" + s;
    }
    function useTimer(running){
      const [elapsed, setElapsed] = React.useState(0);
      const last = React.useRef(null);
      React.useEffect(()=>{
        let id=null;
        const tick=(ts)=>{ if(last.current==null) last.current=ts; setElapsed(p=> p + (ts-last.current)/1000); last.current=ts; id=requestAnimationFrame(tick); };
        if(running) id=requestAnimationFrame(tick);
        return ()=>{ if(id) cancelAnimationFrame(id); last.current=null; };
      },[running]);
      return { elapsed, setElapsed };
    }

    function App(){
      const [level, setLevel] = React.useState(3);
      const [cells, setCells] = React.useState([]);
      const [solution, setSolution] = React.useState([]);
      const [selected, setSelected] = React.useState(null);
      const [notesMode, setNotesMode] = React.useState(false);
      const [autoNotes, setAutoNotes] = React.useState(true);
      const [showConflicts, setShowConflicts] = React.useState(true);
      const [mistakes, setMistakes] = React.useState(0);
      const [difficulty, setDifficulty] = React.useState(0);
      const [targets, setTargets] = React.useState(null);
      const [generating, setGenerating] = React.useState(false);
      const [paused, setPaused] = React.useState(false);
      const [stats, setStats] = React.useState({ totalSolved: 0, bestTimeSec: null, streak: 0, lastSolvedDate: null });
      const [puzzleId, setPuzzleId] = React.useState("");
      const [activeTab, setActiveTab] = React.useState("how");

      const { elapsed, setElapsed } = useTimer(!paused && cells.length>0 && !isSolved(cells, solution));
      function isSolved(cs, sol){ return cs.length===SIZE && cs.every((c,i)=> c.value===sol[i]); }

      React.useEffect(()=>{
        const raw = localStorage.getItem("sudoku-trainer-state-v2");
        if(raw){ try{ const p=JSON.parse(raw);
          setCells(p.cells.map(c=>({ value:c.value, given:c.given, notes:new Set(c.notes) })));
          setSolution(p.solution); setLevel(p.level); setElapsed(p.elapsed||0);
          setDifficulty(p.difficulty||0); setPuzzleId(p.puzzleId||""); setStats(p.stats||stats);
        } catch{} } else { newGame(level); }
      },[]);

      React.useEffect(()=>{
        if(cells.length){
          const p = {
            cells: cells.map(c=>({ value:c.value, given:c.given, notes:[...c.notes] })),
            solution, level, elapsed:Math.floor(elapsed), difficulty, puzzleId, stats
          };
          localStorage.setItem("sudoku-trainer-state-v2", JSON.stringify(p));
        }
      },[cells, solution, level, elapsed, difficulty, puzzleId, stats]);

      function autoFillNotes(cs=cells, sol=solution){
        const next = cs.map((cell,i)=>{
          if(cell.value!==0) return cell;
          const cand = candidatesFor(cs.map(x=>x.value), i);
          return { ...cell, notes:new Set(cand) };
        });
        setCells(next);
      }
      function newGame(lvl=level){
        setGenerating(true);
        setTimeout(()=>{
          const g = generatePuzzle(lvl);
          const cs = g.puzzle.map(v=>({ value:v, given:v!==0, notes:new Set() }));
          setCells(cs); setSolution(g.solution); setSelected(null); setMistakes(0);
          setDifficulty(g.difficulty); setTargets(g.targets); setPaused(false); setElapsed(0);
          setPuzzleId(g.solution.join("")); setGenerating(false);
          if(autoNotes) autoFillNotes(cs, g.solution);
        },10);
      }
      function peersOf(i){
        const r=rowOf(i), c=colOf(i);
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        const s=new Set();
        for(let k=0;k<N;k++){ s.add(idx(r,k)); s.add(idx(k,c)); }
        for(let rr=br; rr<br+3; rr++) for(let cc=bc; cc<bc+3; cc++) s.add(idx(rr,cc));
        s.delete(i); return Array.from(s);
      }
      function setValue(i,v){
        setCells(prev=>{
          const next=prev.slice(); const cell={...next[i]};
          if(cell.given) return prev;
          const prevVal = cell.value;
          if(notesMode){
            const nset = new Set(cell.notes);
            if(v>=1 && v<=9){ if(nset.has(v)) nset.delete(v); else nset.add(v); }
            cell.notes = nset; next[i]=cell; return next;
          }
          cell.value=v; cell.notes=new Set(); next[i]=cell;
          if(showConflicts && v!==0 && v!==solution[i]) setMistakes(m=>m+1);
          if(autoNotes){
            const peers=peersOf(i);
            for(const p of peers) if(next[p].value===0){ const nset=new Set(next[p].notes); nset.delete(v); next[p]={...next[p], notes:nset}; }
          }
          if(v!==prevVal){
            const done = next.every((c,k)=> c.value!==0 && c.value===solution[k]);
            if(done) onSolved();
          }
          return next;
        });
      }
      function clearCell(i){ setValue(i,0); }
      function hint(){
        const empties = range(SIZE).filter(i=> cells[i].value===0);
        if(!empties.length) return;
        let pick = empties.find(i=> candidatesFor(cells.map(c=>c.value), i).length===1);
        if(pick==null) pick = empties[Math.floor(Math.random()*empties.length)];
        setValue(pick, solution[pick]);
      }
      function checkBoard(){
        const wrong = range(SIZE).filter(i=> cells[i].value!==0 && cells[i].value!==solution[i]);
        if(wrong.length) setMistakes(m=> m + wrong.length);
        return wrong.length;
      }
      function onSolved(){
        setPaused(true);
        setStats(prev=>{
          const today = new Date().toISOString().slice(0,10);
          const last = prev.lastSolvedDate;
          const inc = !last || new Date(today) > new Date(last);
          const streak = inc ? (prev.streak + 1) : prev.streak;
          const best = prev.bestTimeSec == null ? Math.floor(elapsed) : Math.min(prev.bestTimeSec, Math.floor(elapsed));
          return { totalSolved: prev.totalSolved + 1, bestTimeSec: best, streak, lastSolvedDate: today };
        });
      }

      React.useEffect(()=>{
        function onKey(e){
          if(selected==null) return;
          if(e.key>='1' && e.key<='9') setValue(selected, parseInt(e.key,10));
          else if(e.key==='Backspace' || e.key==='Delete' || e.key==='0') clearCell(selected);
          else if(e.key==='ArrowUp') setSelected(s=> s==null? null : Math.max(0, s-9));
          else if(e.key==='ArrowDown') setSelected(s=> s==null? null : Math.min(80, s+9));
          else if(e.key==='ArrowLeft') setSelected(s=> s==null? null : Math.max(0, s-1));
          else if(e.key==='ArrowRight') setSelected(s=> s==null? null : Math.min(80, s+1));
          else if(e.key.toLowerCase && e.key.toLowerCase()==='n') setNotesMode(n=>!n);
          else if(e.key.toLowerCase && e.key.toLowerCase()==='h') hint();
        }
        window.addEventListener('keydown', onKey);
        return ()=> window.removeEventListener('keydown', onKey);
      }, [selected, cells, solution, notesMode]);

      const sameVal = React.useMemo(()=>{
        if(selected==null) return new Set();
        const v = cells[selected] && cells[selected].value; if(!v) return new Set();
        const s=new Set(); for(let i=0;i<SIZE;i++) if(cells[i].value===v) s.add(i); return s;
      }, [selected, cells]);

      const progress = React.useMemo(()=>{
        if(!cells.length) return 0;
        const filled = cells.filter(c=> c.value!==0).length;
        return Math.round((filled/SIZE)*100);
      }, [cells]);

      return (
        <div className="w-full min-h-screen bg-neutral-50 text-neutral-900">
          <div className="max-w-6xl mx-auto p-3 sm:p-4 md:p-8">
            <div className="flex items-center gap-3 mb-3 sm:mb-4">
              <div className="w-6 h-6 rounded-full bg-black text-white grid place-items-center text-xs">ğŸ§ </div>
              <h1 className="text-xl sm:text-2xl font-bold">Sudoku Trainer â€” ç„¡é™ãƒ¬ãƒ™ãƒ«</h1>
              <span className="px-2 py-0.5 text-xs rounded-full border bg-white/60">è„³ãƒˆãƒ¬ãƒ»ã‚½ãƒ­å°‚ç”¨</span>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 sm:gap-6">
              <div className="lg:col-span-2 rounded-2xl border bg-white shadow-sm">
                <div className="p-4 border-b flex items-center justify-between">
                  <div className="text-base font-semibold">ãƒœãƒ¼ãƒ‰</div>
                  <div className="flex items-center gap-2 text-sm">
                    <span className="px-2 py-0.5 text-xs rounded-full border bg-white/60">é€²æ— {progress}%</span>
                    <span className="px-2 py-0.5 text-xs rounded-full border bg-white/60">â± {fmtTime(elapsed)}</span>
                    <span className="px-2 py-0.5 text-xs rounded-full border bg-white/60">èª¤ã‚Š {mistakes}</span>
                  </div>
                </div>
                <div className="p-4">
                  <div className="flex flex-col md:flex-row gap-4 sm:gap-6">
                    <div className="mx-auto">
                      <div className="grid grid-cols-9 grid-rows-9 select-none">
                        {range(SIZE).map((i)=>{
                          const r=rowOf(i), c=colOf(i);
                          const cell = cells[i] || { value:0, given:false, notes:new Set() };
                          const isSel = selected===i;
                          const highlight = sameVal.has(i);
                          const wrong = showConflicts && cell.value!==0 && solution[i]!==cell.value && !cell.given;
                          const classes = [
                            "w-9 h-9 sm:w-10 sm:h-10 md:w-12 md:h-12 flex items-center justify-center border text-base sm:text-lg md:text-xl",
                            (c%3===0 ? "border-l-2" : ""),
                            (r%3===0 ? "border-t-2" : ""),
                            (c===8 ? "border-r-2" : ""),
                            (r===8 ? "border-b-2" : ""),
                            (isSel ? "bg-amber-100" : (highlight ? "bg-amber-50" : "bg-white")),
                            (cell.given ? "font-bold" : ""),
                            (wrong ? "text-red-600" : ""),
                          ].join(" ");
                          return (
                            <div key={i} className={classes} onClick={()=> setSelected(i)}>
                              {cell.value!==0 ? (
                                <span>{cell.value}</span>
                              ) : (
                                <div className="grid grid-cols-3 grid-rows-3 w-full h-full p-1 text-[9px] sm:text-[10px] leading-none text-neutral-500">
                                  {range(9).map((n)=>(
                                    <div key={n} className="flex items-center justify-center">
                                      {cell.notes && cell.notes.has(n+1) ? (n+1) : ""}
                                    </div>
                                  ))}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>

                    <div className="flex-1 space-y-4">
                      <div className="rounded-2xl border bg-white shadow-sm">
                        <div className="p-4 border-b"><div className="text-base font-semibold">å…¥åŠ›</div></div>
                        <div className="p-4 space-y-3">
                          <div className="grid grid-cols-5 gap-2">
                            {range(9).map((n)=> (
                              <button key={n} className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=> selected!=null && setValue(selected, n+1)}>{n+1}</button>
                            ))}
                            <button className="border px-3 py-2 rounded-lg hover:bg-neutral-50" onClick={()=> selected!=null && clearCell(selected)}>æ¶ˆå»</button>
                          </div>
                          <div className="flex flex-wrap items-center gap-4 text-sm">
                            <label className="inline-flex items-center gap-2 cursor-pointer">
                              <input type="checkbox" checked={notesMode} onChange={(e)=> setNotesMode(e.target.checked)} />ãƒ¡ãƒ¢ï¼ˆãƒšãƒ³ã‚·ãƒ«ï¼‰
                            </label>
                            <label className="inline-flex items-center gap-2 cursor-pointer">
                              <input type="checkbox" checked={autoNotes} onChange={(e)=> { setAutoNotes(e.target.checked); if(e.target.checked) autoFillNotes(); }} />å€™è£œã‚ªãƒ¼ãƒˆ
                            </label>
                            <label className="inline-flex items-center gap-2 cursor-pointer">
                              <input type="checkbox" checked={showConflicts} onChange={(e)=> setShowConflicts(e.target.checked)} />èª¤ã‚Šãƒã‚§ãƒƒã‚¯
                            </label>
                          </div>
                          <div className="grid grid-cols-3 gap-2">
                            <button className="px-3 py-2 rounded-lg bg-black text-white hover:bg-neutral-800" onClick={hint}>ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
                            <button className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=> setPaused(p=>!p)}>{paused? "å†é–‹":"ä¸€æ™‚åœæ­¢"}</button>
                            <button className="border px-3 py-2 rounded-lg hover:bg-neutral-50" onClick={()=>{ const w=checkBoard(); alert(w? `èª¤ã‚Š ${w} ä»¶ã‚’æ¤œå‡ºã—ã¾ã—ãŸ` : "ç¾æ™‚ç‚¹ã§èª¤ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“"); }}>ãƒã‚§ãƒƒã‚¯</button>
                          </div>
                        </div>
                      </div>

                      <div className="rounded-2xl border bg-white shadow-sm">
                        <div className="p-4 border-b"><div className="text-base font-semibold">æ–°è¦ä½œæˆ / ãƒ¬ãƒ™ãƒ«</div></div>
                        <div className="p-4 space-y-3">
                          <div className="flex items-center gap-2">
                            <button className="border px-3 py-2 rounded-lg hover:bg-neutral-50" onClick={()=> setLevel(l=> Math.max(1,l-1))}>âˆ’</button>
                            <input className="w-24 border rounded-lg p-2" type="number" value={level} onChange={(e)=> setLevel(Math.max(1, Number(e.target.value)||1))} />
                            <button className="border px-3 py-2 rounded-lg hover:bg-neutral-50" onClick={()=> setLevel(l=> l+1)}>ï¼‹</button>
                            <button className="px-3 py-2 rounded-lg bg-black text-white hover:bg-neutral-800" onClick={()=> newGame(level)} disabled={generating}>{generating? "ç”Ÿæˆä¸­...":"æ–°ã—ã„ç›¤é¢"}</button>
                          </div>
                          <div className="text-xs text-neutral-600">ç›®æ¨™ï¼šç©ºãƒã‚¹ {targets?.emptiesTarget ?? "-"}ã€é›£æ˜“åº¦ {targets?.diffTarget ?? "-"} ï¼ æ¨å®š {difficulty}</div>
                          <div className="text-xs text-neutral-500">â€» ãƒ¬ãƒ™ãƒ«ã¯ç†è«–ä¸Šç„¡åˆ¶é™ã€‚è¶…é«˜ãƒ¬ãƒ™ãƒ«ã¯ç”Ÿæˆã«æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</div>
                        </div>
                      </div>

                      <div className="rounded-2xl border bg-white shadow-sm">
                        <div className="p-4 border-b"><div className="text-base font-semibold">çµ±è¨ˆ</div></div>
                        <div className="p-4 text-sm grid grid-cols-2 gap-2">
                          <div>ã‚¯ãƒªã‚¢æ•°: <span className="font-bold">{stats.totalSolved}</span></div>
                          <div>ãƒ™ã‚¹ãƒˆ: <span className="font-bold">{stats.bestTimeSec==null? "-" : fmtTime(stats.bestTimeSec)}</span></div>
                          <div>é€£ç¶šæ—¥æ•°: <span className="font-bold">{stats.streak}</span></div>
                          <div>ãƒ‘ã‚ºãƒ«ID: <span className="font-mono">{puzzleId? (puzzleId.slice(0,8)+"â€¦") : "-"}</span></div>
                          <div className="col-span-2 flex gap-2 mt-1 flex-wrap">
                            <button className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=>{
                              const p = {
                                cells: cells.map(c=>({ value:c.value, given:c.given, notes:[...c.notes] })),
                                solution, level, elapsed:Math.floor(elapsed), difficulty, puzzleId, stats
                              };
                              const blob = new Blob([JSON.stringify(p,null,2)], { type:"application/json" });
                              const url = URL.createObjectURL(blob);
                              const a = document.createElement("a"); a.href=url; a.download="sudoku_"+((p.puzzleId||"00000000").slice(0,8))+".json"; a.click(); URL.revokeObjectURL(url);
                            }}>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                            <button className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=>{
                              const inp = document.createElement("input"); inp.type="file"; inp.accept="application/json";
                              inp.onchange = ()=>{ const f=inp.files && inp.files[0]; if(!f) return; const fr=new FileReader(); fr.onload=()=>{ try{ const p=JSON.parse(String(fr.result));
                                setCells(p.cells.map(c=>({ value:c.value, given:c.given, notes:new Set(c.notes) })));
                                setSolution(p.solution); setLevel(p.level); setElapsed(p.elapsed||0); setDifficulty(p.difficulty||0); setPuzzleId(p.puzzleId||""); setStats(p.stats||stats);
                              } catch{ alert("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ"); } }; fr.readAsText(f); };
                              inp.click();
                            }}>ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                            <button className="border px-3 py-2 rounded-lg hover:bg-neutral-50" onClick={()=> newGame(level)}>ãƒªã‚»ãƒƒãƒˆ</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="mt-4 sm:mt-6 flex flex-wrap items-center gap-2 justify-between text-xs text-neutral-500">
                    <div>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰: 1â€“9 å…¥åŠ› / 0 or Backspace ã§æ¶ˆå» / çŸ¢å°ã§ç§»å‹• / N=ãƒ¡ãƒ¢åˆ‡æ›¿ / H=ãƒ’ãƒ³ãƒˆ</div>
                  </div>
                </div>
              </div>

              <div className="rounded-2xl border bg-white shadow-sm">
                <div className="p-4 border-b">
                  <div className="text-base font-semibold">ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°</div>
                  <div className="mt-2 flex gap-2 text-sm">
                    <button className="px-3 py-2 rounded-lg bg-black text-white hover:bg-neutral-800" onClick={()=> setActiveTab('how')}>éŠã³æ–¹</button>
                    <button className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=> setActiveTab('modes')}>ãƒ¢ãƒ¼ãƒ‰</button>
                    <button className="px-3 py-2 rounded-lg bg-neutral-200 hover:bg-neutral-300" onClick={()=> setActiveTab('tips')}>ã‚³ãƒ„</button>
                  </div>
                </div>
                <div className="p-4 space-y-3 text-sm">
                  {activeTab==='how' && (
                    <div className="space-y-2">
                      <p>æ¨™æº–çš„ãª 9Ã—9 æ•°ç‹¬ã€‚<strong>ãƒ¬ãƒ™ãƒ«</strong>ã¯ç†è«–ä¸Šç„¡åˆ¶é™ã§ã€ä¸Šã’ã‚‹ã»ã©ç©ºãƒã‚¹ãŒå¢—ãˆã€æ¢ç´¢é›£åº¦ã‚‚ä¸ŠãŒã‚Šã¾ã™ã€‚</p>
                      <ul className="list-disc pl-5 space-y-1">
                        <li>ã‚»ãƒ«é¸æŠå¾Œã€æ•°å­—ã‚­ãƒ¼ã§å…¥åŠ›ã€‚<em>ãƒ¡ãƒ¢</em>ONæ™‚ã¯å€™è£œã‚’ãƒˆã‚°ãƒ«ã€‚</li>
                        <li>ã€Œå€™è£œã‚ªãƒ¼ãƒˆã€ONã§ç©ºãƒã‚¹ã«è‡ªå‹•å€™è£œã€‚</li>
                        <li>ãƒ’ãƒ³ãƒˆã¯ 1 ãƒã‚¹ã ã‘æ­£è§£ã‚’åŸ‹ã‚ã¾ã™ã€‚</li>
                      </ul>
                    </div>
                  )}
                  {activeTab==='modes' && (
                    <div className="space-y-2">
                      <p>è„³ãƒˆãƒ¬ã‚’æ„è­˜ã—ãŸ 3 è¦ç´ ï¼š</p>
                      <ul className="list-disc pl-5 space-y-1">
                        <li><strong>æ™‚é–“ç®¡ç†</strong>ï¼šã‚¿ã‚¤ãƒãƒ¼ã¨ãƒ™ã‚¹ãƒˆæ›´æ–°ã€‚</li>
                        <li><strong>æ­£ç¢ºæ€§</strong>ï¼šèª¤ã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆOFFã§é›£åº¦UPï¼‰ã€‚</li>
                        <li><strong>è¨˜æ†¶ã¨æ¨è«–</strong>ï¼šãƒ¡ãƒ¢æ´»ç”¨ã¨å€™è£œå‰Šæ¸›ã®ç­‹é“ã€‚</li>
                      </ul>
                    </div>
                  )}
                  {activeTab==='tips' && (
                    <div className="space-y-2">
                      <p>åˆç´š: ã‚·ãƒ³ã‚°ãƒ«ï¼ˆè£¸/éš ã‚Œï¼‰ï¼ä¸­ç´š: ãƒšã‚¢/ãƒˆãƒªãƒ—ãƒ«ï¼ä¸Šç´š: X-Wing ç­‰ã€‚æœ¬ã‚¢ãƒ—ãƒªã®é›£æ˜“åº¦ã¯ <em>æ¢ç´¢ã‚¹ãƒ†ãƒƒãƒ—/ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯</em>é‡ã§è¿‘ä¼¼è©•ä¾¡ã€‚</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
</body>
</html>
